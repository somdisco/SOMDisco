<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 4 SOM Initialization | SOMDisco</title>
  <meta name="description" content="Chapter 4 SOM Initialization | SOMDisco" />
  <meta name="generator" content="bookdown 0.20 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 4 SOM Initialization | SOMDisco" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 4 SOM Initialization | SOMDisco" />
  
  
  

<meta name="author" content="Josh Taylor" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="shgr-example-data.html"/>
<link rel="next" href="som-learning.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="background.html"><a href="background.html"><i class="fa fa-check"></i><b>1</b> Background</a><ul>
<li class="chapter" data-level="1.1" data-path="background.html"><a href="background.html#kohonens-som"><i class="fa fa-check"></i><b>1.1</b> Kohonen’s SOM</a></li>
<li class="chapter" data-level="1.2" data-path="background.html"><a href="background.html#conscience-som"><i class="fa fa-check"></i><b>1.2</b> Conscience SOM</a></li>
<li class="chapter" data-level="1.3" data-path="background.html"><a href="background.html#the-cadj-matrix"><i class="fa fa-check"></i><b>1.3</b> The CADJ Matrix</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="installation.html"><a href="installation.html"><i class="fa fa-check"></i><b>2</b> Installation</a></li>
<li class="chapter" data-level="3" data-path="shgr-example-data.html"><a href="shgr-example-data.html"><i class="fa fa-check"></i><b>3</b> SHGR Example Data</a></li>
<li class="chapter" data-level="4" data-path="som-initialization.html"><a href="som-initialization.html"><i class="fa fa-check"></i><b>4</b> SOM Initialization</a><ul>
<li class="chapter" data-level="4.1" data-path="som-initialization.html"><a href="som-initialization.html#lattice-quantitites"><i class="fa fa-check"></i><b>4.1</b> Lattice Quantitites</a></li>
<li class="chapter" data-level="4.2" data-path="som-initialization.html"><a href="som-initialization.html#network-scaling"><i class="fa fa-check"></i><b>4.2</b> Network Scaling</a></li>
<li class="chapter" data-level="4.3" data-path="som-initialization.html"><a href="som-initialization.html#prototype-initialization"><i class="fa fa-check"></i><b>4.3</b> Prototype Initialization</a></li>
<li class="chapter" data-level="4.4" data-path="som-initialization.html"><a href="som-initialization.html#win-frequency-initialization"><i class="fa fa-check"></i><b>4.4</b> Win Frequency Initialization</a></li>
<li class="chapter" data-level="4.5" data-path="som-initialization.html"><a href="som-initialization.html#learning-rate-initialization"><i class="fa fa-check"></i><b>4.5</b> Learning Rate Initialization</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="som-learning.html"><a href="som-learning.html"><i class="fa fa-check"></i><b>5</b> SOM Learning</a><ul>
<li class="chapter" data-level="5.1" data-path="som-learning.html"><a href="som-learning.html#network-training"><i class="fa fa-check"></i><b>5.1</b> Network Training</a></li>
<li class="chapter" data-level="5.2" data-path="som-learning.html"><a href="som-learning.html#secRecall"><i class="fa fa-check"></i><b>5.2</b> Network Recall</a><ul>
<li class="chapter" data-level="5.2.1" data-path="som-learning.html"><a href="som-learning.html#bmu---som-forwad-map"><i class="fa fa-check"></i><b>5.2.1</b> BMU - SOM Forwad Map</a></li>
<li class="chapter" data-level="5.2.2" data-path="som-learning.html"><a href="som-learning.html#rf_members---som-reverse-map"><i class="fa fa-check"></i><b>5.2.2</b> RF_members - SOM Reverse Map</a></li>
<li class="chapter" data-level="5.2.3" data-path="som-learning.html"><a href="som-learning.html#rf_size"><i class="fa fa-check"></i><b>5.2.3</b> RF_size</a></li>
<li class="chapter" data-level="5.2.4" data-path="som-learning.html"><a href="som-learning.html#quantization-error"><i class="fa fa-check"></i><b>5.2.4</b> Quantization Error</a></li>
<li class="chapter" data-level="5.2.5" data-path="som-learning.html"><a href="som-learning.html#entropy"><i class="fa fa-check"></i><b>5.2.5</b> Entropy</a></li>
<li class="chapter" data-level="5.2.6" data-path="som-learning.html"><a href="som-learning.html#u-matrix-fences"><i class="fa fa-check"></i><b>5.2.6</b> U-Matrix Fences</a></li>
<li class="chapter" data-level="5.2.7" data-path="som-learning.html"><a href="som-learning.html#cadj-conn"><i class="fa fa-check"></i><b>5.2.7</b> CADJ &amp; CONN</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="som-learning.html"><a href="som-learning.html#recalling-labeled-data"><i class="fa fa-check"></i><b>5.3</b> Recalling Labeled Data</a></li>
<li class="chapter" data-level="5.4" data-path="som-learning.html"><a href="som-learning.html#monitoring-learning"><i class="fa fa-check"></i><b>5.4</b> Monitoring Learning</a></li>
<li class="chapter" data-level="5.5" data-path="som-learning.html"><a href="som-learning.html#parallel-processing"><i class="fa fa-check"></i><b>5.5</b> Parallel Processing</a></li>
<li class="chapter" data-level="5.6" data-path="som-learning.html"><a href="som-learning.html#saving-loading"><i class="fa fa-check"></i><b>5.6</b> Saving &amp; Loading</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="secVis.html"><a href="secVis.html"><i class="fa fa-check"></i><b>6</b> A Complete Example with Visualizations</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">SOMDisco</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="som-initialization" class="section level1">
<h1><span class="header-section-number">Chapter 4</span> SOM Initialization</h1>
<p>SOMDisco is built around the internal C++ class <code>SOMOBJ</code>, which is a header-only class (found in the <code>/inst/include/</code> source package) envisioned to be entirely portable for future integration with other SOM-related projects. This section will demonstrate how to interact with the class fields and methods to achieve SOM training (a complete list of the fields and methods of this class exposed to the user by the SOMDisco package can be found with <code>?SOM</code>). All methods are documented in the usual manner, with help functionality available via <code>?&lt;method_name&gt;</code>.</p>
<p>To get started with SOM training we must instantiate an empty <code>SOM</code> object, then initialize it with our training data and desired lattice size and topology via the method <code>initialize_SOM</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">library</span>(SOMDisco)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">mysom =<span class="st"> </span>SOM<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">mysom<span class="op">$</span><span class="kw">initialize_SOM</span>(SHGR<span class="op">$</span>X, <span class="dv">20</span>, <span class="dv">20</span>, <span class="st">&quot;hex&quot;</span>)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">## Setting lattice quantities</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">## ++ calculating lattice (x,y) coordinates ... done</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co">## ++ calculating neuron lattice adjacencies ... done</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="co">## ++ calculating geodesic lattice distances between neurons ... done</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="co">## ++ assigning geodesic lattice distances to distlist ... done</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="co">## ++ calculating lattice tile vertices ... done</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="co">## ----------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="co">## Setting training data</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="co">## ----------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"><span class="co">## Setting network ranges</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="co">## ++ external = [-115.19, 1347.57]</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="co">## ++ internal = [0.00, 1.00]</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="co">## ++ change defaults via $set_netrng</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17"><span class="co">## ----------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="co">## Initializing prototypes to random uniform</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19"><span class="co">## ++ to set a particular random seed call set.seed() and then $set_W_runif()</span></a>
<a class="sourceLine" id="cb3-20" data-line-number="20"><span class="co">## ++ to set to specific values call $set_W()</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21"><span class="co">## ----------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22"><span class="co">## Initializing prototype win frequencies to equiprobable</span></a>
<a class="sourceLine" id="cb3-23" data-line-number="23"><span class="co">## ++ to set to specific values call $set_p(values)</span></a>
<a class="sourceLine" id="cb3-24" data-line-number="24"><span class="co">## ----------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25"><span class="co">## Setting default learning rates</span></a>
<a class="sourceLine" id="cb3-26" data-line-number="26"><span class="co">## Storing the annealing schedule as:</span></a>
<a class="sourceLine" id="cb3-27" data-line-number="27"><span class="co">## t	alpha	beta	gamma	sigma</span></a>
<a class="sourceLine" id="cb3-28" data-line-number="28"><span class="co">## 16384	0.50	0.05	0.01	3</span></a>
<a class="sourceLine" id="cb3-29" data-line-number="29"><span class="co">## 81920	0.25	0.03	0.00	2</span></a>
<a class="sourceLine" id="cb3-30" data-line-number="30"><span class="co">## 163840	0.10	0.01	0.00	1</span></a>
<a class="sourceLine" id="cb3-31" data-line-number="31"><span class="co">## 409600	0.05	0.01	0.00	1</span></a>
<a class="sourceLine" id="cb3-32" data-line-number="32"><span class="co">## 1638400	0.01	0.00	0.00	1</span></a>
<a class="sourceLine" id="cb3-33" data-line-number="33"><span class="co">## ++ change via $get_LRAS and $set_LRAS</span></a>
<a class="sourceLine" id="cb3-34" data-line-number="34"><span class="co">## ----------------------------------------------------------------</span></a></code></pre></div>
<p>The arguments to <code>initialize_SOM</code> are, in order: the matrix with training data in rows, the desired som lattice width and height (number of neurons along each dimension) and the desired lattice type, which can be either <code>&quot;hex&quot;</code> for hexagonal lattices or <code>&quot;grid&quot;</code> for rectangular lattices. Internally, <code>initialize_SOM</code> calls several other methods to set required (and internally calculated) quantities related to the SOM lattice, and default parameters for network scaling, prototype initialization, and learning rate annealing. The sample size <code>nX</code> and data dimension <code>d</code> are also stored during this call.</p>
<div id="lattice-quantitites" class="section level2">
<h2><span class="header-section-number">4.1</span> Lattice Quantitites</h2>
<p>Lattice quantities are fields that generally begin with <code>nu_*</code> (by our convention, lattice neurons are represented by lower Greek <span class="math inline">\(\nu\)</span>). These fields can be examined via the <code>$</code> operator of of the instantiated SOM object:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># The lattice width, height, and type, respectively </span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">mysom<span class="op">$</span>som_x</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">## [1] 20</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">mysom<span class="op">$</span>som_y</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">## [1] 20</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">mysom<span class="op">$</span>lattice_type</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="co">## [1] &quot;hex&quot;</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="co"># The total number of neurons / prototypes in the SOM. </span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="co"># For hexagonal lattices, this number will be &gt; som_x*som_y</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">mysom<span class="op">$</span>nW</a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="co">## [1] 410</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14"><span class="co"># The (x,y) coordinates of the neurons on the SOM lattice</span></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="kw">str</span>(mysom<span class="op">$</span>nu_xy)</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"><span class="co">##  num [1:410, 1:2] 1 2 3 4 5 6 7 8 9 10 ...</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17"></a>
<a class="sourceLine" id="cb4-18" data-line-number="18"><span class="co"># The (row,col) coordinates of the neurons on the SOM lattice. </span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19"><span class="co"># These differ from their (x,y) coordinates if lattice_type = &#39;hex&#39;</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20"><span class="kw">str</span>(mysom<span class="op">$</span>nu_ij)</a>
<a class="sourceLine" id="cb4-21" data-line-number="21"><span class="co">##  num [1:410, 1:2] 1 1 1 1 1 1 1 1 1 1 ...</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22"></a>
<a class="sourceLine" id="cb4-23" data-line-number="23"><span class="co"># A binary adjacency matrix representing the topology of neurons on the lattice</span></a>
<a class="sourceLine" id="cb4-24" data-line-number="24"><span class="kw">str</span>(mysom<span class="op">$</span>nu_ADJ)</a>
<a class="sourceLine" id="cb4-25" data-line-number="25"><span class="co">##  num [1:410, 1:410] 1 1 0 0 0 0 0 0 0 0 ...</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26"></a>
<a class="sourceLine" id="cb4-27" data-line-number="27"><span class="co"># The (x,y) coordinates of the vertices of each lattice tile are stored </span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28"><span class="co"># in a 3d cube whose slices follow neuron ordering. </span></a>
<a class="sourceLine" id="cb4-29" data-line-number="29"><span class="kw">str</span>(mysom<span class="op">$</span>nu_verts)</a>
<a class="sourceLine" id="cb4-30" data-line-number="30"><span class="co">##  num [1:6, 1:2, 1:410] 1.5 1 0.5 0.5 1 ...</span></a>
<a class="sourceLine" id="cb4-31" data-line-number="31"><span class="co"># e.g., the vertices of the lattice tile centered at the first neuron are: </span></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">mysom<span class="op">$</span>nu_verts[,,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb4-33" data-line-number="33"><span class="co">##      [,1]      [,2]</span></a>
<a class="sourceLine" id="cb4-34" data-line-number="34"><span class="co">## [1,]  1.5 1.2886751</span></a>
<a class="sourceLine" id="cb4-35" data-line-number="35"><span class="co">## [2,]  1.0 1.5773503</span></a>
<a class="sourceLine" id="cb4-36" data-line-number="36"><span class="co">## [3,]  0.5 1.2886751</span></a>
<a class="sourceLine" id="cb4-37" data-line-number="37"><span class="co">## [4,]  0.5 0.7113249</span></a>
<a class="sourceLine" id="cb4-38" data-line-number="38"><span class="co">## [5,]  1.0 0.4226497</span></a>
<a class="sourceLine" id="cb4-39" data-line-number="39"><span class="co">## [6,]  1.5 0.7113249</span></a>
<a class="sourceLine" id="cb4-40" data-line-number="40"></a>
<a class="sourceLine" id="cb4-41" data-line-number="41"><span class="co"># A list giving, for all neurons, the indices of others neurons that are </span></a>
<a class="sourceLine" id="cb4-42" data-line-number="42"><span class="co"># within a certain lattice geodesic distance: </span></a>
<a class="sourceLine" id="cb4-43" data-line-number="43"><span class="kw">length</span>(mysom<span class="op">$</span>nu_nhblist)</a>
<a class="sourceLine" id="cb4-44" data-line-number="44"><span class="co">## [1] 410</span></a>
<a class="sourceLine" id="cb4-45" data-line-number="45"></a>
<a class="sourceLine" id="cb4-46" data-line-number="46"><span class="co"># The vector nu_nhblist[[i]][[j]] contains indices of neurons that are </span></a>
<a class="sourceLine" id="cb4-47" data-line-number="47"><span class="co"># within geodesic lattice distace j-1 of neuron i. </span></a>
<a class="sourceLine" id="cb4-48" data-line-number="48"><span class="co"># ex., these neurons are within lattice distance = 1 of the first lattice neuron: </span></a>
<a class="sourceLine" id="cb4-49" data-line-number="49">mysom<span class="op">$</span>nu_nhblist[[<span class="dv">1</span>]][[<span class="dv">2</span>]]</a>
<a class="sourceLine" id="cb4-50" data-line-number="50"><span class="co">## [1]  2 21 22</span></a></code></pre></div>
<p>The above quantities are set by the method <code>set_lattice</code>, but this should rarely need to be called on its own (it is called internally by <code>initialize_SOM</code>). All containers storing neuron and prototype quantities are ordered such that the first element (or row, or slice, as applicable) corresponds to the neuron at the bottom left of the SOM lattice. Ordering proceeds across the rows of the lattice so that the last element (row, slice) corresponds to the neuron at the top right of the SOM.<br />
<img src="SOMDisco.README_files/figure-html/ck-SHGRSOMneuronorder-1.png" width="672" /></p>
<p>This is known as <strong>neuron ordering</strong></p>
</div>
<div id="network-scaling" class="section level2">
<h2><span class="header-section-number">4.2</span> Network Scaling</h2>
<p>The <strong>external network range</strong> is the apparent range of the training data. Internally, the SOM prototypes are stored in an <strong>internal&quot; network range</strong>, which is necessary to stabilize and accelerate the training process. Both BMU selection and prototype updates are performed in the internal network range. During training, data are mapped (linearly) from the external to internal range for presentation to the network. <code>initialize_SOM</code> calls the method <code>set_netrng</code> internally, which sets the min/max of both the external and internal network ranges needed for this mapping to their defaults (which is the apparent dimension-wise range of the training data for the former, and [0,1] for the latter):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># The default values stored </span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">str</span>(mysom<span class="op">$</span>netrng_ext_min)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="co">##  num [1, 1:100] -115 -115 -115 -115 -115 ...</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">str</span>(mysom<span class="op">$</span>netrng_ext_max)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="co">##  num [1, 1:100] 1348 1348 1348 1348 1348 ...</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">mysom<span class="op">$</span>netrng_int_min</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="co">## [1] 0</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">mysom<span class="op">$</span>netrng_int_max</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="co">## [1] 1</span></a></code></pre></div>
<p>The default network scalings can be changed manually by calling <code>set_netrng</code> at any point prior to training. See its help for more information.</p>
<p>Once the network ranges are set, data can be mapped from external to internal network ranges (or vice-versa) via the methods <code>map_to_netrng</code> and <code>map_from_netrng</code>, both of which are parallelized. For example, the entire training set can be mapped to the internal network range via:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">range</span>(SHGR<span class="op">$</span>X)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co">## [1] -115.1884 1347.5741</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">mapped_training_data =<span class="st"> </span>mysom<span class="op">$</span><span class="kw">map_to_netrng</span>(SHGR<span class="op">$</span>X)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">range</span>(mapped_training_data)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="co">## [1] 0 1</span></a></code></pre></div>
<p>Commonly, the learned SOM prototypes would need to be extracted from the SOM object and returned to external range for direct comparison with the data. This can be achived by:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">range</span>(mysom<span class="op">$</span>W)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">## [1] 0.5000002 0.5999968</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">mapped_prototypes =<span class="st"> </span>mysom<span class="op">$</span><span class="kw">map_from_netrng</span>(mysom<span class="op">$</span>W)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">range</span>(mapped_prototypes)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="co">## [1] 616.1932 762.4644</span></a></code></pre></div>
</div>
<div id="prototype-initialization" class="section level2">
<h2><span class="header-section-number">4.3</span> Prototype Initialization</h2>
<p>The SOM prototype weights are stored in the rows of the <code>nW x d</code> prototype matrix <code>W</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">str</span>(mysom<span class="op">$</span>W)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">##  num [1:410, 1:100] 0.595 0.57 0.589 0.518 0.563 ...</span></a></code></pre></div>
<p><code>initialize_SOM</code> calls the method <code>set_W_runif</code> automatically, which initializes the prototypes to random uniform values over the middle 10% of the internal network range. If random seeding of these values is desired for reproducibility, this method should be re-invoked immediately after a call to R’s <code>set.seed</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">123</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">mysom<span class="op">$</span><span class="kw">set_W_runif</span>()</a></code></pre></div>
<p>Custom prototype initializations are supported by the general method <code>set_W</code>, which allows the user to set a desired prototype weight matrix (which must have conforming dimensions: nrows = <code>nW</code> and ncols = <code>d</code>) Here, we set them to random standard normals for demo purposes:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">rnorm_protos =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(mysom<span class="op">$</span>nW<span class="op">*</span>mysom<span class="op">$</span>d), <span class="dt">nrow=</span>mysom<span class="op">$</span>nW, <span class="dt">ncol=</span>mysom<span class="op">$</span>d)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">mysom<span class="op">$</span><span class="kw">set_W</span>(rnorm_protos)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="co">## Warning in mysom$set_W(rnorm_protos): Input is outside netrng_int. Likely need</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="co">## to scale to internal network range, then call $set_W()</span></a></code></pre></div>
<p>A warning is issued if the prototype matrix contains values outside the internal network range. Custom initializations will likely need to be mapped to internal range prior to setting:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">rnorm_protos =<span class="st"> </span>mysom<span class="op">$</span><span class="kw">map_to_netrng</span>(rnorm_protos)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">mysom<span class="op">$</span><span class="kw">set_W</span>(rnorm_protos)</a></code></pre></div>
</div>
<div id="win-frequency-initialization" class="section level2">
<h2><span class="header-section-number">4.4</span> Win Frequency Initialization</h2>
<p>In addition to the prototypes themselves, DeSieno’s CSOM algorithm introduces another learned quantity to facilitate a maximum-entropy SOM mapping: the prototype win frequencies, which are stored in the SOM object in the vector <code>p</code>. The <code>p</code> control the CSOM prototype <code>bias</code>, which affects the competitive stage of BMU selection during SOM training. <code>initialize_SOM</code> automatically calls the method <code>set_p_equal</code>, which sets all prototype win frequences to the value <code>1 / nW</code>. If desired, other initializations can be achieved via the method <code>set_p</code>, which takes a user-specified vector of win frequencies:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">new_p =<span class="st"> </span><span class="kw">runif</span>(mysom<span class="op">$</span>nW)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">mysom<span class="op">$</span><span class="kw">set_p</span>(new_p)</a></code></pre></div>
</div>
<div id="learning-rate-initialization" class="section level2">
<h2><span class="header-section-number">4.5</span> Learning Rate Initialization</h2>
<p>All CSOM learning rates should be annealed over time. Annealing is controlled by the internally stored data frame <code>LRAS</code> (or Learning Rate Annealing Schedule), which has columns <code>t</code> (setting the cumulative number of training steps over which the given rates are valid), <code>alpha</code> (controlling the strength of the prototype updates), <code>beta</code> (controlling the strength of win frequncy updates), <code>gamma</code> (controlling the influence of the win frequences to the CSOM bias), and <code>sigma</code> (controlling the lattice neighborhood size over which prototype updates occur). <code>initialize_SOM</code> calls the stand-alone function <code>default_LRAS</code> by default, which populates an annealing schedule based solely on the training sample size:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">default_LRAS</span>(<span class="dt">nX =</span> mysom<span class="op">$</span>nX)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="co">##         t alpha  beta  gamma sigma</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="co">## 1   16384  0.50 0.050 0.0050     3</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="co">## 2   81920  0.25 0.025 0.0025     2</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="co">## 3  163840  0.10 0.010 0.0010     1</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="co">## 4  409600  0.05 0.005 0.0005     1</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="co">## 5 1638400  0.01 0.001 0.0001     1</span></a></code></pre></div>
<p>Users can check the current annealing schedule of the SOM object via the method <code>get_LRAS</code> and set it to new values with <code>set_LRAS</code>, which takes a data frame of the above form as input. For example, the below will increase the <code>alpha</code> values for all training steps by 10%:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">new_LRAS =<span class="st"> </span>mysom<span class="op">$</span><span class="kw">get_LRAS</span>()</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">new_LRAS<span class="op">$</span>alpha =<span class="st"> </span><span class="fl">1.10</span> <span class="op">*</span><span class="st"> </span>new_LRAS<span class="op">$</span>alpha </a>
<a class="sourceLine" id="cb14-3" data-line-number="3">mysom<span class="op">$</span><span class="kw">set_LRAS</span>(new_LRAS) </a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="co">## Storing the annealing schedule as:</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="co">## t	alpha	beta	gamma	sigma</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="co">## 16384	0.55	0.05	0.01	3</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="co">## 81920	0.28	0.03	0.00	2</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="co">## 163840	0.11	0.01	0.00	1</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="co">## 409600	0.06	0.01	0.00	1</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="co">## 1638400	0.01	0.00	0.00	1</span></a></code></pre></div>
<p>At every training step the currently applicable learning rates (based on the SOM’s age and the LRAS schedule) are extracted from the LRAS data frame and stored in the following fields by the method <code>update_learning_rates</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">mysom<span class="op">$</span>alpha</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co">## [1] 0.55</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">mysom<span class="op">$</span>beta</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="co">## [1] 0.05</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">mysom<span class="op">$</span>gamma</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="co">## [1] 0.005</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">mysom<span class="op">$</span>sigma</a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="co">## [1] 3</span></a></code></pre></div>
<p>The parameter <code>sigma</code> controls the size of the (lattice) neighborhood (of the prevailing BMU) in which prototypes are updated during each training step. The strength of neighbor updates decreases with their lattice distance from the BMU; the prototypes of any neurons which are greater than <code>sigma</code> away from the BMU will not be updated. The strength of updates to prototype whose neurons are within a <code>sigma</code> lattice radius of the BMU decreases exponentially with this lattice distance. This factor is stored in the SOM object as the parameter <code>eta</code>, which is a vector of length <code>sigma + 1</code>. The vector element <code>eta[r]</code> stores a multiplicative coefficient applied to the updates of those prototypes which are distance <code>r-1</code> from the BMU.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">mysom<span class="op">$</span>eta</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co">##           [,1]</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="co">## [1,] 1.0000000</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="co">## [2,] 1.0000000</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="co">## [3,] 0.5994843</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="co">## [4,] 0.3593814</span></a></code></pre></div>
<p><code>eta</code> is re-calculated any time the effective <code>sigma</code> value is changed (annealed) during training. To enforce the organization of the SOM, <code>eta</code> always = 1 for the BMU and its immediate lattice neighbors. <code>eta</code> is calculated via the method <code>calc_eta</code>, which should rarely need to be called on its own.</p>
<p>Of note, Kohonen’s original prototype algorithm (i.e, without DeSieno’s Conscience modification) can be achieved by setting <code>beta</code> and <code>gamma</code> to 0 and annealing a larger <code>sigma</code> radius over time.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="shgr-example-data.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="som-learning.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["SOMDisco.README.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
