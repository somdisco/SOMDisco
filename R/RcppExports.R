# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute distances between rows of two matrices
#'
#' @param X1 a data matrix, vectors in rows 
#' @param X2 a data matrix, vectors in rows. ncol(X2) must equal ncol(X1). 
#' @param which_dist optional, the distance to compute. Options are \itemize{\item "L2" for Euclidean, \item "L22" for Squared Euclidean", \item "L1" for L-1 distance, \item "LInf" for L-Inf distance} Default = "L22".
#' @param parallel optional, whether to compute in parallel. Default = TRUE
#' @param bias optional, a vector of bias to be applied to the distance calculation when computing BMU. 
#' Default = NULL, meaning no bias is applied. If given, length(bias) must equal nrow(X2) (one bias for every row of X2).
#' @param X1min optional, a vector giving the minimum of the range of X1 used in any linearly scaling before distances are computed. 
#' Default = NULL, meaning no scaling is applied. 
#' @param X1max optional, a vector giving the maximum of the range of X1 used in any linearly scaling before distances are computed. 
#' Default = NULL, meaning no scaling is applied. 
#' @param X2min optional, a vector giving the minimum of the range of X2 used in any linearly scaling before distances are computed. 
#' Default = NULL, meaning no scaling is applied. 
#' @param X2max optional, a vector giving the maximum of the range of X2 used in any linearly scaling before distances are computed. 
#' Default = NULL, meaning no scaling is applied. 
#' 
#' @details 
#' If given, bias affects the distance calculation between the rows of X1 and X2 by: which_dist(X1[i,], X2[j,]) - bias[j]. 
#' 
#' The inputs X1min, X1max, X2min, X2max control any linearly scaling (from the range of X1, to that of X2) that is applied prior to distance calculation. 
#' If any of the above are given, they all must be given.  Each can be given as either a vector controlling ranges by dimension (length = ncol(X1)), 
#' or a length 1 vector (in which case the single value will be recycled across dimensions).  
#' 
#' Specifying scaling forces distance computation to be performed in the X2 range. This is an optional feature.
#' 
#' @return a matrix whose (i,j) entry contains the requested distance between the i-th row of X1 and and j-th row of X2
#' 
#' @export
distmat <- function(X1, X2, which_dist = "L22", parallel = TRUE, bias = NULL, X1min = NULL, X1max = NULL, X2min = NULL, X2max = NULL) {
    .Call(`_SOMDisco_distmat`, X1, X2, which_dist, parallel, bias, X1min, X1max, X2min, X2max)
}

#' Shortest path distances between vertices of a graph
#' 
#' @description This is a wrapper for igraph::distances, see its help for more information. 
#' 
#' @param ADJ the adjacency matrix of graph vertices. Can be weighted. 
#' @param weighted optional, whether to consider the edge weights found in ADJ and construct a weighted graph. Default = FALSE. 
#' @param directed optional, whether to consider the graph as directed. Default = FALSE. 
#' 
#' @return a shortest-path distance matrix between graph vertices (nrow = ncol = num. vertices)
#' 
#' @export
geodesicdist <- function(ADJ, weighted = FALSE, directed = FALSE) {
    .Call(`_SOMDisco_geodesicdist`, ADJ, weighted, directed)
}

#' Find BMU of data vectors 
#' 
#' @param X a data matrix, vectors in rows 
#' @param W a prototype matrix, vectors in rows
#' @param nBMU optional, the number of BMUs returned. Default = 2. 
#' @param parallel optional, whether to compute in parallel. Default = TRUE
#' @param bias optional, a vector of bias to be applied to the distance calculation when computing BMU. 
#' Default = NULL, meaning no bias is applied. If given, length(bias) must equal nrow(W) (one bias for every prototype).
#' @param Xmin optional, a vector giving the minimum of the range of X used in any linearly scaling before distances are computed. 
#' Default = NULL, meaning no scaling is applied. 
#' @param Xmax optional, a vector giving the maximum of the range of X used in any linearly scaling before distances are computed. 
#' Default = NULL, meaning no scaling is applied. 
#' @param Wmin optional, a vector giving the minimum of the range of W used in any linearly scaling before distances are computed. 
#' Default = NULL, meaning no scaling is applied. 
#' @param Wmax optional, a vector giving the maximum of the range of W used in any linearly scaling before distances are computed. 
#' Default = NULL, meaning no scaling is applied. 
#' 
#' @details If given, bias affects the distance calculation between the rows of X and W by: dist(X[i,], W[j,]) - bias[j]. 
#' 
#' The inputs Xmin, Xmax, Wmin, Wmax control any linearly scaling that is applied prior to distance calculation. 
#' If any of the above are given, they all must be given.  Each can be given as either a vector controlling ranges by dimension (length = ncol(W)), 
#' or a length 1 vector (in which case the single value will be recycled across dimensions).  Specifying the X and W ranges is only useful 
#' if you are trying to match a BMU selection that was performed during SOM training, which utilized an external / internal network range.  
#' 
#' @return a list with components 
#' \itemize{ 
#'   \item BMU a matrix (nrow = nrow(X), ncol = nBMU) whose (i,j) entry lists the index (the row of W, 1-based) of the j-th BMU of the i-th row of X. 
#'   \item SQE a vector (length = nrow(X)) whose i-th element gives the Squared Quantization Error of the i-th row of X
#' }
#' 
#' @export
find_BMU <- function(X, W, nBMU = 2L, parallel = TRUE, bias = NULL, Xmin = NULL, Xmax = NULL, Wmin = NULL, Wmax = NULL) {
    .Call(`_SOMDisco_find_BMU`, X, W, nBMU, parallel, bias, Xmin, Xmax, Wmin, Wmax)
}

#' Build a CADJ matrix
#' 
#' @param BMU matrix (nrow = nrow(X), ncol = nBMU) of indices (1-based) of the BMUs of each data vector in X. 
#' @param nW the number of SOM prototypes (CADJ matrices have nrow = ncol = nW)
#' @param parallel optional, whether to compute in parallel. Default = TRUE
#' 
#' @details The input BMU matrix should be the result of calling \code{find_BMU} with \code{nBMU} >= 2.  
#' 
#' @return a CADJ matrix 
#' 
#' @export
build_CADJ <- function(BMU, nW, parallel = TRUE) {
    .Call(`_SOMDisco_build_CADJ`, BMU, nW, parallel)
}

#' Produce a list of data vectors in each prototype's Receptive Field 
#' 
#' @param BMU matrix (nrow = nrow(X), ncol = nBMU) of indices (1-based) of the BMUs of each data vector in X. 
#' @param nW the number of SOM prototypes (CADJ matrices have nrow = ncol = nW)
#' @param parallel optional, whether to compute in parallel. Default = TRUE
#' 
#' @details The input BMU matrix should be the result of calling \code{find_BMU} with \code{nBMU} >= 2.  
#' 
#' @return a list (length = nW), containing the (1-based) indices of the data vectors mapped to each prototype. 
#' 
#' @export
find_RF_members <- function(BMU, nW, parallel = TRUE) {
    .Call(`_SOMDisco_find_RF_members`, BMU, nW, parallel)
}

#' Compute the plurality label of each prototype. 
#' 
#' @description For labeled data mapped to each prototype's Receptive Field, the plurality label
#' is returned. 
#' 
#' @param X_label a vector (length = nrow(X)) of data labels
#' @param RF_members a list containing the (1-based) indices of the data vectors mapped to each prototype, 
#' as returned by \code{find_RF_members}. 
#' @param parallel optional, whether to compute in parallel. Default = TRUE
#' 
#' @return a vector of prototype labels. If a prototype's Receptive Field is empty the returned label is NA
#' 
#' @export
find_RF_label <- function(X_label, RF_members, parallel = TRUE) {
    .Call(`_SOMDisco_find_RF_label`, X_label, RF_members, parallel)
}

#' Receptive Field Summary Statistics
#' 
#' @description Compute summary statistics of each Receptive Field of a vector quantizer, given its forward mapping. 
#' A forward mapping is a vector containing the prototype index to which each data vector is mapped. 
#' 
#' @param X_vals the (possibly multivariate) data values to be summarized, as a matrix (nrows = nrow(X), ncol = num. dimensions)
#' @param fwdmap a vector (length = nrow(X)) of indices (1-based) describing the forward mapping. 
#' The i-th element of FWDmap should contain the index of the prototype that the i-th data vector is mapped to. 
#' @param nW the total number of prototypes in the vector quantizer 
#' @param stat the statistic to compute. Possible values are 
#' \itemize{
#' \item count \item sum \item mean \item sd \item q0 (min) \item q25 (first quantile) \item q50 (median) \item q75 (third quantile) \item q100 (max)
#' }
#' @param parallel optional, whether to compute in parallel. Default = TRUE
#' 
#' @details The statistics are computed individually for each data dimension. 
#' The statistics for any prototypes in the vector quantizer whose Receptive Fields are empty (no data mapped to them) are returned as NA. 
#' The rows of the returned matrix of statistics represent prototype-level summary statistics (row1 contains stats of prototype1, etc.).
#' 
#' @return a matrix (nrows = nW, ncol = num. data dimensions) containing the requested statistic for each prototype
#' 
#' @export
summarystat_RF_fwdmap <- function(X_vals, fwdmap, nW, stat = "mean", parallel = TRUE) {
    .Call(`_SOMDisco_summarystat_RF_fwdmap`, X_vals, fwdmap, nW, stat, parallel)
}

#' Receptive Field Summary Statistics
#' 
#' @description Compute summary statistics of each Receptive Field of a vector quantizer, given its reverse mapping. 
#' A reverse mapping is a list containing the data indices in the Receptive Field of each prototype. 
#' 
#' @param X_vals the (possibly multivariate) data values to be summarized, as a matrix (nrows = nrow(X), ncol = num. dimensions)
#' @param revmap a list (length = nW) of indices (1-based) describing the reverse mapping. 
#' The i-th element of REVmap should contain the indices of data vectors that are mapped to the the i-th prototype of the quantizer. 
#' @param stat the statistic to compute. Possible values are 
#' \itemize{
#' \item count \item sum \item mean \item sd \item q0 (min) \item q25 (first quantile) \item q50 (median) \item q75 (third quantile) \item q100 (max)
#' }
#' @param parallel optional, whether to compute in parallel. Default = TRUE
#' 
#' @details The statistics are computed individually for each data dimension. 
#' The statistics for any prototypes in the vector quantizer whose Receptive Fields are empty (no data mapped to them) are returned as NA. 
#' The rows of the returned matrix of statistics represent prototype-level summary statistics (row1 contains stats of prototype1, etc.).
#' 
#' @return a matrix (nrows = nW, ncol = num. data dimensions) containing the requested statistic for each prototype
#' 
#' @export
summarystat_RF_revmap <- function(X_vals, revmap, stat = "mean", parallel = TRUE) {
    .Call(`_SOMDisco_summarystat_RF_revmap`, X_vals, revmap, stat, parallel)
}

#' Calculate the fences of the SOM lattice 
#' 
#' @description Lattice fences between neighboring neurons on the lattice are the (squared) Euclidean distance between 
#' the neurons' corresponding prototypes. 
#' 
#' @param nu_xy a matrix whose rows contain the (x,y) coordinates (cols 1 and 2, respectively) of each lattice neuron, ordered 
#' from the bottom-left of the lattice. 
#' @param W the prototype matrix (rows ordered the same as nu_xy)
#' @param nu_verts a 3-d array whose slices contain the vertices of each lattice tile (slices ordered the same as nu_xy)
#' @param nu_ADJ the neuron adjacency matrix 
#' @param parallel optional, whether to compute in parallel. Default = TRUE
#' 
#' @return A data frame identifying the fence and its corresponding value between each pair of neighboring lattice neurons, with columns: 
#' \itemize{
#' \item i the index of the 1st neuron comprising the fence 
#' \item j the index of the 2nd neuron comprising the fence
#' \item x0 the lattice x-coord of neuron i 
#' \item y0 the lattice y-coord of neuron i 
#' \item x1 the lattice x-coord of neuron j 
#' \item y1 the lattice y-coord of neuron j
#' \item value the fence value separating neurons i and j 
#' }
#' 
#' @export 
calc_SOM_fences <- function(nu_xy, W, nu_verts, nu_ADJ, parallel = TRUE) {
    .Call(`_SOMDisco_calc_SOM_fences`, nu_xy, W, nu_verts, nu_ADJ, parallel)
}

#' Linear scaling of the rows of a data matrix
#' 
#' Each row is mapped linearly from a given range, to a given range
#' 
#' @param X a data matrix with vectors in rows
#' @param from_min a vector defining the min from which X is scaled, by dimension
#' @param from_max a vector defining the max from which X is scaled, by dimension
#' @param to_min a vector defining the min to which X is scaled, by dimension
#' @param to_max a vector defining the max to which X is scaled, by dimension
#' @param parallel boolean, whether to compute in parallel
#' 
#' @return a matrix (same dimensions as X) whose rows are scaled to the requested range
#' 
#' @export
linscale <- function(X, from_min, from_max, to_min, to_max, parallel = TRUE) {
    .Call(`_SOMDisco_linscale`, X, from_min, from_max, to_min, to_max, parallel)
}

